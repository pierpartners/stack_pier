<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>n8n Dependency Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0d1117;
            color: #c9d1d9;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 320px;
            background: #161b22;
            border-right: 1px solid #30363d;
            padding: 20px;
            overflow-y: auto;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .controls {
            background: #161b22;
            border-bottom: 1px solid #30363d;
            padding: 16px 24px;
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .graph-container {
            flex: 1;
            position: relative;
            height: 100%;
            min-height: 500px;
        }

        h1 {
            font-size: 20px;
            margin-bottom: 20px;
            color: #58a6ff;
        }

        h2 {
            font-size: 14px;
            margin: 20px 0 12px;
            color: #8b949e;
            text-transform: uppercase;
            font-weight: 600;
        }

        input[type="text"],
        input[type="file"],
        select {
            width: 100%;
            padding: 8px 12px;
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            color: #c9d1d9;
            font-size: 14px;
            margin-bottom: 12px;
        }

        input::placeholder {
            color: #6e7681;
        }

        button {
            padding: 8px 16px;
            background: #238636;
            border: none;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }

        button:hover {
            background: #2ea043;
        }

        button.secondary {
            background: #21262d;
            border: 1px solid #30363d;
        }

        button.secondary:hover {
            background: #30363d;
        }

        .tool-item {
            padding: 8px 12px;
            margin: 4px 0;
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .tool-item:hover {
            background: #161b22;
            border-color: #58a6ff;
        }

        .tool-item.selected {
            background: #1f6feb;
            border-color: #58a6ff;
            color: white;
        }

        .tool-count {
            float: right;
            background: #30363d;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
        }

        .impact-panel {
            margin-top: 20px;
            padding: 16px;
            background: #21262d;
            border: 1px solid #30363d;
            border-radius: 6px;
        }

        .impact-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #f85149;
        }

        .impact-list {
            list-style: none;
        }

        .impact-list li {
            padding: 6px 0;
            border-bottom: 1px solid #30363d;
            font-size: 13px;
        }

        .impact-list li:last-child {
            border-bottom: none;
        }

        .node {
            cursor: pointer;
        }

        .node circle {
            stroke: #30363d;
            stroke-width: 2px;
            fill: #8b949e;
            /* Cor padr√£o para visibilidade */
        }

        .node text {
            font-size: 11px;
            fill: #c9d1d9;
            pointer-events: none;
        }

        .link {
            stroke: #30363d;
            stroke-opacity: 0.6;
            stroke-width: 1.5px;
            fill: none;
        }

        .link.highlighted {
            stroke: #58a6ff;
            stroke-width: 2.5px;
            stroke-opacity: 1;
        }

        .node.highlighted circle {
            stroke: #58a6ff;
            stroke-width: 3px;
        }

        .node.workflow circle {
            fill: #f85149;
            stroke: #f85149;
        }

        /* Workflow Red */
        .node.supabase circle {
            fill: #3ECF8E;
        }

        /* Supabase Green */
        .node.notion circle {
            fill: #a371f7;
        }

        /* Notion Purple */
        .node.bigquery circle {
            fill: #4285f4;
        }

        /* BigQuery Blue */
        .node.microsoft circle {
            fill: #f9ba48;
        }

        /* Microsoft Orange */
        .node.google circle {
            fill: #ff00ff;
        }

        /* Google Yellow */
        .node.openai circle {
            fill: #ffffff;
            stroke: #30363d;
            stroke-width: 2px;
        }

        /* OpenAI White */

        /* Credencial GENERICO */
        .node.credential circle {
            fill: transparent;
            stroke: #8b949e;
            stroke-width: 2px;
            stroke-dasharray: 4;
        }

        /* Credencial - Bordas Coloridas por Plataforma */
        .node.credential.supabase circle {
            stroke: #3ECF8E;
        }

        .node.credential.notion circle {
            stroke: #a371f7;
        }

        .node.credential.bigquery circle {
            stroke: #4285f4;
        }

        .node.credential.microsoft circle {
            stroke: #f9ba48;
        }

        .node.credential.google circle {
            stroke: #ff00ff;
        }

        .node.credential.openai circle {
            stroke: #ffffff !important;
        }

        /* Group Nodes */
        .node.group circle {
            stroke-width: 3px;
            stroke-dasharray: 5, 5;
            fill-opacity: 0.3;
            cursor: pointer;
        }

        .node.group:hover circle {
            stroke-width: 4px;
            fill-opacity: 0.5;
        }

        /* Define specialized group styling if needed, otherwise handled via inline color */


        .node.group text {
            font-weight: bold;
            font-size: 14px;
        }

        .stats {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
        }

        .stat-box {
            flex: 1;
            background: #0d1117;
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #30363d;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #58a6ff;
        }

        .stat-label {
            font-size: 11px;
            color: #8b949e;
            margin-top: 4px;
        }

        .legend {
            display: flex;
            gap: 16px;
            font-size: 12px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .legend-item:hover {
            background: #21262d;
        }

        .legend-item.collapsed {
            opacity: 0.5;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        #fileInput {
            display: none;
        }

        .export-btn {
            margin-left: auto;
        }

        .category-header {
            font-weight: 600;
            margin-top: 12px;
            margin-bottom: 4px;
            color: #8b949e;
            font-size: 12px;
            text-transform: capitalize;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .category-header:hover {
            color: #58a6ff;
        }

        .category-toggle {
            font-size: 10px;
            background: #30363d;
            padding: 2px 6px;
            border-radius: 4px;
        }

        .folder-upload {
            display: block;
            width: 100%;
            padding: 12px;
            background: #21262d;
            border: 2px dashed #30363d;
            border-radius: 6px;
            text-align: center;
            cursor: pointer;
            margin-bottom: 20px;
            transition: all 0.2s;
        }

        .folder-upload:hover {
            border-color: #58a6ff;
            background: #262c36;
        }

        .folder-upload span {
            display: block;
            font-size: 13px;
            color: #8b949e;
            margin-top: 4px;
        }

        #folderInput {
            display: none;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="sidebar">
            <h1>n8n Dependencies</h1>

            <!-- Loader / Connection Panel -->
            <div id="connectionPanel">
                <h2>Conex√£o n8n</h2>
                <div id="autoLoadStatus" style="display:none; color: #8b949e; font-size: 13px; margin-bottom: 12px;">
                </div>

                <div id="manualConnect" style="display:none;">
                    <div class="folder-upload" onclick="document.getElementById('folderInput').click()">
                        <strong>üìÅ Carregar Pasta de Workflows</strong>
                        <span>Selecione a pasta 'n8n_workflows_export'</span>
                    </div>
                    <input type="file" id="folderInput" webkitdirectory directory multiple
                        onchange="handleFolderSelect(event)">

                    <div style="text-align: center; margin: 15px 0; color: #8b949e; font-size: 12px;">‚Äî OU ‚Äî</div>

                    <input type="text" id="n8nUrl" placeholder="URL do n8n (ex: https://n8n.seudominio.com)">
                    <input type="password" id="n8nKey" placeholder="API Key (X-N8N-API-KEY)">
                    <button onclick="fetchFromApi()" style="width: 100%">Conectar & Carregar via API</button>
                    <div style="margin-top: 8px; font-size: 11px; color: #8b949e;">
                        *Requer configura√ß√£o de CORS no n8n.
                    </div>
                </div>
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-value" id="workflowCount">0</div>
                    <div class="stat-label">Fluxos</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="sourceCount">0</div>
                    <div class="stat-label">Fontes</div>
                </div>
            </div>

            <input type="text" id="searchInput" placeholder="üîç Buscar fluxo, ferramenta ou tabela...">

            <h2>Filtrar por Fonte de Dados</h2>
            <div id="toolsList"></div>

            <div id="impactPanel" class="impact-panel" style="display: none;">
                <div class="impact-title">Fluxos relacionados</div>
                <div id="impactText"></div>
                <ul class="impact-list" id="impactList"></ul>
            </div>
        </div>

        <div class="main-content">
            <div class="controls">
                <div class="legend" id="legend">
                    <!-- Legend items will be generated dynamically -->
                </div>
                <button class="secondary" onclick="resetZoom()">üîÑ Reset Zoom</button>
                <button class="secondary export-btn" onclick="exportMarkdown()">üìÑ Exportar MD</button>
            </div>
            <div class="graph-container" id="graph"></div>
        </div>
    </div>

    <script>
        let rawNodes = [];
        let rawLinks = [];
        let graphData = { nodes: [], links: [] };
        let simulation;
        let svg, g;
        let selectedTool = null;

        // Grouping State (true = expanded, false = collapsed)
        // User requested condensed by default
        let groupState = {
            workflow: false,
            supabase: false,
            notion: false,
            bigquery: false,
            microsoft: false,
            google: false,
            openai: false,
            other: false
        };

        const colorMap = {
            workflow: '#f85149',
            supabase: '#3ecf8e',
            notion: '#a371f7',
            bigquery: '#4285f4',
            microsoft: '#f9ba48',
            google: '#ff00ff',
            openai: '#ffffff',
            other: '#8b949e'
        };

        // Initialize graph
        function initGraph() {
            const container = d3.select('#graph');
            container.selectAll('*').remove(); // Garante que n√£o duplique o SVG

            const width = container.node().getBoundingClientRect().width || 800;
            const height = container.node().getBoundingClientRect().height || 600;

            console.log('Iniciando grafo com dimens√µes:', width, height);

            svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);


            console.log('Graph initialized with dims:', width, height);


            g = svg.append('g');

            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => g.attr('transform', event.transform));

            svg.call(zoom);

            simulation = d3.forceSimulation()
                .force('link', d3.forceLink().id(d => d.id).distance(150))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(40));

            updateLegend();
        }

        function resetZoom() {
            svg.transition().duration(750).call(
                d3.zoom().transform,
                d3.zoomIdentity
            );
        }

        function updateLegend() {
            const legend = document.getElementById('legend');
            legend.innerHTML = '';

            Object.keys(groupState).forEach(type => {
                const item = document.createElement('div');
                item.className = `legend-item ${groupState[type] ? 'expanded' : 'collapsed'}`;
                item.onclick = () => toggleGroup(type);

                const dot = document.createElement('div');
                dot.className = 'legend-dot';
                dot.style.background = colorMap[type] || '#ccc';
                if (type === 'openai') dot.style.border = '1px solid #30363d';

                const label = document.createTextNode(
                    type === 'workflow' ? 'n8n' :
                        type.charAt(0).toUpperCase() + type.slice(1)
                );

                item.appendChild(dot);
                item.appendChild(label);

                // Add state indicator
                const state = document.createElement('span');
                state.style.fontSize = '10px';
                state.style.marginLeft = '4px';
                state.style.color = '#8b949e';
                state.textContent = groupState[type] ? '(Expandido)' : '(Agrupado)';
                item.appendChild(state);

                legend.appendChild(item);
            });
        }

        function toggleGroup(type) {
            groupState[type] = !groupState[type];
            updateLegend();
            updateGraphData();
        }

        // Process n8n JSON files
        function processWorkflows(files) {
            rawNodes = [];
            rawLinks = [];
            const nodeMap = new Map();

            // Helper to extract value from n8n parameters (handle strings or RL objects)
            const getVal = (v) => {
                if (v === null || v === undefined) return '';
                if (typeof v === 'string') return v;
                if (typeof v === 'object') {
                    return v.cachedResultName || v.value || JSON.stringify(v);
                }
                return String(v);
            };

            files.forEach(workflow => {

                const workflowId = workflow.id;
                const workflowName = workflow.name;

                // Add workflow node
                addNode(nodeMap, workflowId, workflowName, 'workflow');

                // Process nodes
                (workflow.nodes || []).forEach(node => {
                    const nodeType = node.type;
                    const params = node.parameters || {};
                    const creds = node.credentials || {};

                    // OpenAI
                    if (nodeType.includes('openai') || nodeType.includes('OpenAi') || creds.openAiApi) {
                        const modelName = getVal(params.model || params.modelId || params.modelName || 'OpenAI');
                        const sourceId = `openai_${modelName}`;
                        addNode(nodeMap, sourceId, modelName, 'openai');
                        rawLinks.push({ source: workflowId, target: sourceId, type: 'uses' });

                        if (creds.openAiApi) {
                            const credName = getVal(creds.openAiApi.name || creds.openAiApi.id || 'OpenAI API');
                            const credId = `cred_openai_${credName}`;
                            // Use distinct type for credentials to keep them clustered differently if needed
                            addNode(nodeMap, credId, `Cred: ${credName}`, 'credential openai');
                            rawLinks.push({ source: sourceId, target: credId, type: 'auth' });
                        }
                    }

                    // Qdrant (Vector Store)
                    if (nodeType.includes('qdrant') || nodeType.includes('Qdrant') || creds.qdrantRestApi || creds.qdrantApi) {
                        const qCreds = creds.qdrantRestApi || creds.qdrantApi;
                        const collection = getVal(params.collectionName || params.qdrantCollection || 'Qdrant');
                        const sourceId = `qdrant_${collection}`;
                        addNode(nodeMap, sourceId, collection, 'other');
                        rawLinks.push({ source: workflowId, target: sourceId, type: 'uses' });

                        if (qCreds) {
                            const credName = getVal(qCreds.name || qCreds.id || 'Qdrant API');
                            const credId = `cred_qdrant_${credName}`;
                            addNode(nodeMap, credId, `Cred: ${credName}`, 'credential other');
                            rawLinks.push({ source: sourceId, target: credId, type: 'auth' });
                        }
                    }


                    // Supabase
                    if (nodeType.includes('supabase') || nodeType.includes('Supabase') || nodeType.includes('vectorStoreSupabase')) {
                        const tableName = getVal(params.tableName || 'Supabase');
                        if (tableName) {
                            const sourceId = `supabase_${tableName}`;
                            addNode(nodeMap, sourceId, tableName, 'supabase');
                            rawLinks.push({ source: workflowId, target: sourceId, type: 'uses' });

                            if (creds.supabaseApi) {
                                const cName = getVal(creds.supabaseApi.name || creds.supabaseApi.id || 'Supabase API');
                                const credId = `cred_supabase_${cName}`;
                                addNode(nodeMap, credId, `Cred: ${cName}`, 'credential supabase');
                                rawLinks.push({ source: sourceId, target: credId, type: 'auth' });
                            }
                        }
                    }


                    // Notion
                    if (nodeType.includes('notion') || nodeType.includes('Notion')) {
                        const databaseName = getVal(params.databaseId || params.tableName || 'Notion');
                        if (databaseName) {
                            const sourceId = `notion_${databaseName}`;
                            addNode(nodeMap, sourceId, databaseName, 'notion');
                            rawLinks.push({ source: workflowId, target: sourceId, type: 'uses' });

                            if (creds.notionApi) {
                                const cName = getVal(creds.notionApi.name || creds.notionApi.id || 'Notion API');
                                const credId = `cred_notion_${cName}`;
                                addNode(nodeMap, credId, `Cred: ${cName}`, 'credential notion');
                                rawLinks.push({ source: sourceId, target: credId, type: 'auth' });
                            }
                        }
                    }


                    // BigQuery
                    if (nodeType.includes('bigquery') || nodeType.includes('BigQuery')) {
                        let tableName = null;
                        if (params.tableId) {
                            tableName = typeof params.tableId === 'string' ? params.tableId : params.tableId.value;
                        } else if (params.datasetId && params.tableId) {
                            tableName = `${params.datasetId}.${params.tableId}`;
                        }

                        if (tableName) {
                            const sourceId = `bigquery_${tableName}`;
                            addNode(nodeMap, sourceId, tableName, 'bigquery');
                            rawLinks.push({ source: workflowId, target: sourceId, type: 'uses' });

                            if (creds.googleBigQueryOAuth2Api) {
                                const credId = `cred_bigquery_${creds.googleBigQueryOAuth2Api.name || creds.googleBigQueryOAuth2Api.id}`;
                                addNode(nodeMap, credId, creds.googleBigQueryOAuth2Api.name || 'BigQuery API', 'credential bigquery');
                                rawLinks.push({ source: sourceId, target: credId, type: 'auth' });
                            }
                        }
                    }

                    // Microsoft SharePoint
                    if (nodeType.includes('httpRequest') && creds.microsoftSharePointOAuth2Api) {
                        const url = params.url || '';
                        const match = url.match(/\/sites\/([^\/]+)/);
                        const siteName = match ? match[1] : 'SharePoint';

                        const sourceId = `microsoft_${siteName}`;
                        addNode(nodeMap, sourceId, siteName, 'microsoft');
                        rawLinks.push({ source: workflowId, target: sourceId, type: 'uses' });

                        const credId = `cred_microsoft_${creds.microsoftSharePointOAuth2Api.name || creds.microsoftSharePointOAuth2Api.id}`;
                        addNode(nodeMap, credId, creds.microsoftSharePointOAuth2Api.name || 'Microsoft SharePoint', 'credential microsoft');
                        rawLinks.push({ source: sourceId, target: credId, type: 'auth' });
                    }

                    // Microsoft Outlook
                    if (nodeType.includes('microsoftOutlook')) {
                        let calendarName = 'Calendar';
                        if (params.calendarId?.cachedResultName) {
                            calendarName = params.calendarId.cachedResultName;
                        }

                        const sourceId = `microsoft_${calendarName}`;
                        addNode(nodeMap, sourceId, calendarName, 'microsoft');
                        rawLinks.push({ source: workflowId, target: sourceId, type: 'uses' });

                        if (creds.microsoftOutlookOAuth2Api) {
                            const credId = `cred_microsoft_${creds.microsoftOutlookOAuth2Api.name || creds.microsoftOutlookOAuth2Api.id}`;
                            addNode(nodeMap, credId, creds.microsoftOutlookOAuth2Api.name || 'Microsoft Outlook', 'credential microsoft');
                            rawLinks.push({ source: sourceId, target: credId, type: 'auth' });
                        }
                    }

                    // Google Calendar
                    if (nodeType.includes('googleCalendar')) {
                        let calendarName = 'Google Calendar';
                        if (params.calendarId?.cachedResultName) {
                            calendarName = params.calendarId.cachedResultName;
                        }

                        const sourceId = `google_${calendarName}`;
                        addNode(nodeMap, sourceId, calendarName, 'google');
                        rawLinks.push({ source: workflowId, target: sourceId, type: 'uses' });

                        if (creds.googleCalendarOAuth2Api) {
                            const credId = `cred_google_${creds.googleCalendarOAuth2Api.name || creds.googleCalendarOAuth2Api.id}`;
                            addNode(nodeMap, credId, creds.googleCalendarOAuth2Api.name || 'Google Calendar', 'credential google');
                            rawLinks.push({ source: sourceId, target: credId, type: 'auth' });
                        }
                    }
                });
            });

            rawNodes = Array.from(nodeMap.values());
            updateToolsList(); // Should be called before updateGraphData? Or inside. It is called inside.
            updateGraphData();
            setTimeout(resetZoom, 500); // Ensure view is centered after load
        }

        function updateGraphData() {
            // Map to track rawId -> activeId (could be same or group id)
            const idMap = new Map();
            const visibleNodes = new Map();

            // 1. Determine active nodes based on group state
            rawNodes.forEach(node => {
                // Use getGroup to consistently determine the group, handling credentials correctly
                let effectiveGroup = getGroup(node);

                if (groupState[effectiveGroup] === false) {
                    // Collapsed: map to group node
                    const groupId = `group_${effectiveGroup}`;
                    idMap.set(node.id, groupId);

                    if (!visibleNodes.has(groupId)) {
                        let labelName = effectiveGroup === 'workflow' ? 'n8n' : effectiveGroup.charAt(0).toUpperCase() + effectiveGroup.slice(1);

                        visibleNodes.set(groupId, {
                            id: groupId,
                            label: `${labelName}`,
                            type: 'group',
                            groupType: effectiveGroup,
                            count: 1,
                            x: node.x || undefined,
                            y: node.y || undefined
                        });
                    } else {
                        visibleNodes.get(groupId).count++;
                        let labelName = effectiveGroup === 'workflow' ? 'n8n' : effectiveGroup.charAt(0).toUpperCase() + effectiveGroup.slice(1);
                        visibleNodes.get(groupId).label = `${labelName} (${visibleNodes.get(groupId).count})`;
                    }
                } else {
                    // Expanded: keep as is
                    idMap.set(node.id, node.id);
                    visibleNodes.set(node.id, node);
                }
            });

            graphData.nodes = Array.from(visibleNodes.values());

            // 2. Aggregate links
            const linkMap = new Map();

            rawLinks.forEach(link => {
                const sourceId = idMap.get(link.source);
                const targetId = idMap.get(link.target);

                // Filter self-loops if source and target collapsed into same group
                if (sourceId && targetId && sourceId !== targetId) {
                    const key = `${sourceId}->${targetId}`;
                    if (!linkMap.has(key)) {
                        // Create new link object to avoid reference issues
                        linkMap.set(key, {
                            source: sourceId,
                            target: targetId,
                            type: link.type,
                            id: key
                        });
                    }
                }
            });

            graphData.links = Array.from(linkMap.values());

            updateStats();
            updateToolsList();
            renderGraph();
        }

        function addNode(map, id, label, type) {
            if (!map.has(id)) {
                map.set(id, { id, label, type });
            }
        }

        function updateStats() {
            // Calculate stats based on RAW data to show total available
            const workflows = rawNodes.filter(n => n.type === 'workflow').length;
            const sources = rawNodes.filter(n =>
                n.type.includes('supabase') || n.type.includes('notion') || n.type.includes('bigquery') ||
                n.type.includes('microsoft') || n.type.includes('google') || n.type.includes('openai')
            ).filter(n => !n.type.includes('credential')).length;

            document.getElementById('workflowCount').textContent = workflows;
            document.getElementById('sourceCount').textContent = sources;
        }

        function updateToolsList() {
            // Build list from GRAPH data (visible nodes) or RAW data? 
            // Usually filter list should show everything available.
            // Let's use RAW nodes so we can always see and filter everything.

            const sources = rawNodes.filter(n =>
                (n.type.includes('supabase') || n.type.includes('notion') || n.type.includes('bigquery') ||
                    n.type.includes('microsoft') || n.type.includes('google') || n.type.includes('openai')) &&
                !n.type.includes('credential')
            );

            const toolsList = document.getElementById('toolsList');
            toolsList.innerHTML = '';

            // Agrupa por tipo
            const grouped = {};
            sources.forEach(source => {
                let type = getGroup(source);
                if (!grouped[type]) grouped[type] = [];
                grouped[type].push(source);
            });

            Object.keys(grouped).sort().forEach(type => {
                const header = document.createElement('div');
                header.className = 'category-header';
                header.innerHTML = `${type} <span class="category-toggle">${groupState[type] ? 'Expandido' : 'Agrupado'}</span>`;
                header.onclick = () => toggleGroup(type);
                toolsList.appendChild(header);

                // Only show individual items if expanded? No, users might want to filter even if grouped in graph.
                // But if grouped in graph, highlighting a specific node might effectively highlight the group.
                // Let's show items always.

                grouped[type].forEach(source => {
                    // Count usages
                    const count = rawLinks.filter(l =>
                        (l.target === source.id) &&
                        (rawNodes.find(n => n.id === l.source)?.type === 'workflow')
                    ).length;

                    const div = document.createElement('div');
                    div.className = 'tool-item';
                    div.innerHTML = `${source.label} <span class="tool-count">${count}</span>`;
                    div.onclick = (e) => {
                        e.stopPropagation();
                        // If group is collapsed, maybe we should expand it to show the specific node?
                        // Or just highlight the group node.
                        // Let's just highlight whatever is visible corresponding to this node.
                        selectTool(source.id, div);
                    };
                    toolsList.appendChild(div);
                });
            });
        }

        function selectTool(toolId, element) {
            document.querySelectorAll('.tool-item').forEach(el => el.classList.remove('selected'));
            element.classList.add('selected');
            selectedTool = toolId;
            highlightDependencies(toolId);
            showImpactAnalysis(toolId);
        }

        function highlightDependencies(toolId) {
            d3.selectAll('.node').classed('highlighted', false);
            d3.selectAll('.link').classed('highlighted', false);

            // Find effective ID in the current graph (could be group ID)
            let effectiveId = toolId;
            const node = rawNodes.find(n => n.id === toolId);

            // Determine if this tool is currently grouped
            let isGrouped = false;
            if (node) {
                let effectiveGroup = getGroup(node);

                if (groupState[effectiveGroup] === false) {
                    effectiveId = `group_${effectiveGroup}`;
                    isGrouped = true;
                }
            }

            // Highlight the effective node (group or individual)
            d3.selectAll('.node').filter(d => d.id === effectiveId).classed('highlighted', true);

            // Find related nodes
            const relatedNodes = new Set([effectiveId]);

            graphData.links.forEach(link => {
                const targetId = link.target.id || link.target;
                const sourceId = link.source.id || link.source;

                if (targetId === effectiveId) {
                    relatedNodes.add(sourceId);
                    d3.selectAll('.link').filter(d =>
                        (d.target.id || d.target) === targetId &&
                        (d.source.id || d.source) === sourceId
                    ).classed('highlighted', true);
                }

                if (sourceId === effectiveId) {
                    relatedNodes.add(targetId);
                    d3.selectAll('.link').filter(d =>
                        (d.source.id || d.source) === sourceId &&
                        (d.target.id || d.target) === targetId
                    ).classed('highlighted', true);
                }
            });

            d3.selectAll('.node').filter(d => relatedNodes.has(d.id))
                .classed('highlighted', true);
        }

        function showImpactAnalysis(toolId) {
            // Analyze impact based on RAW data to be accurate regardless of visual grouping
            const affectedWorkflows = rawLinks
                .filter(l => l.target === toolId)
                .map(l => rawNodes.find(n => n.id === l.source))
                .filter(n => n && n.type === 'workflow');

            const panel = document.getElementById('impactPanel');
            const list = document.getElementById('impactList');
            const text = document.getElementById('impactText');

            if (affectedWorkflows.length > 0) {
                panel.style.display = 'block';
                text.textContent = `${affectedWorkflows.length} fluxo(s) ser√£o afetados:`;
                list.innerHTML = '';
                affectedWorkflows.forEach(wf => {
                    const li = document.createElement('li');
                    li.textContent = wf.label;
                    list.appendChild(li);
                });
            } else {
                panel.style.display = 'none';
            }
        }

        function renderGraph() {
            console.log('Rendering graph with:', graphData.nodes.length, 'nodes and', graphData.links.length, 'links');

            if (graphData.nodes.length === 0) {
                console.warn('No nodes to render');
                return;
            }

            g.selectAll('*').remove();

            const link = g.append('g')
                .selectAll('path')
                .data(graphData.links)
                .enter().append('path')
                .attr('class', 'link');

            const node = g.append('g')
                .selectAll('g')
                .data(graphData.nodes)
                .enter().append('g')
                .attr('class', d => `node ${d.type}`)
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended))
                .on('click', (event, d) => {
                    if (d.type === 'group') {
                        event.stopPropagation();
                        // Expand group
                        toggleGroup(d.groupType);
                    }
                });

            node.append('circle')
                .attr('r', d => {
                    if (d.type === 'group') return 30 + (d.count * 0.5); // Dynamic size
                    return d.type === 'workflow' ? 20 : 15;
                })
                .style('stroke', d => {
                    if (d.type === 'group') return colorMap[d.groupType] || '#30363d';
                    return null; // CSS handles others
                })
                .style('fill', d => {
                    if (d.type === 'group') return colorMap[d.groupType] || '#ccc';
                    return null; // CSS handles others
                });

            // Add tooltip title
            node.append('title')
                .text(d => {
                    if (d.type === 'group') {
                        return `${d.groupType === 'workflow' ? 'n8n' : d.groupType} Group\n${d.count} items`;
                    }
                    if (d.type === 'workflow') {
                        return `n8n workflow\n${d.label}`;
                    }
                    return d.label;
                });

            node.append('text')
                .attr('dy', d => d.type === 'group' ? 45 : 30)
                .attr('text-anchor', 'middle')
                .text(d => {
                    const label = d.label || d.id || 'Desconhecido';
                    if (d.type === 'group') return label;
                    return label.length > 15 ? label.substring(0, 15) + '...' : label;
                });

            simulation.nodes(graphData.nodes);
            simulation.force('link').links(graphData.links);

            const groups = {};
            graphData.nodes.forEach(d => {
                const group = d.type === 'group' ? 'group' : getGroup(d);
                if (!groups[group]) groups[group] = [];
                groups[group].push(d);
            });

            simulation.on('tick', () => {
                const alpha = simulation.alpha();
                const k = alpha * 0.5; // Stronger clustering


                Object.values(groups).forEach(groupNodes => {
                    if (groupNodes.length < 2) return;
                    let x = 0, y = 0, count = 0;
                    groupNodes.forEach(d => {
                        if (!isNaN(d.x) && !isNaN(d.y)) {
                            x += d.x; y += d.y; count++;
                        }
                    });
                    if (count > 0) {
                        x /= count; y /= count;
                        groupNodes.forEach(d => {
                            if (!isNaN(d.x) && !isNaN(d.y)) {
                                d.x += (x - d.x) * k;
                                d.y += (y - d.y) * k;
                            }
                        });
                    }
                });

                link.attr('d', d => {
                    if (!d.source || !d.target || isNaN(d.source.x) || isNaN(d.target.x)) return null;
                    return `M${d.source.x},${d.source.y}L${d.target.x},${d.target.y}`;
                });

                node.attr('transform', d => {
                    if (isNaN(d.x) || isNaN(d.y)) return null;
                    return `translate(${d.x},${d.y})`;
                });
            });

            simulation.alpha(1).restart();
        }

        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // Search functionality
        document.getElementById('searchInput').addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            d3.selectAll('.node').classed('highlighted', false);

            if (term) {
                d3.selectAll('.node')
                    .filter(d => d.label.toLowerCase().includes(term))
                    .classed('highlighted', true);
            }
        });

        // Initialize
        initGraph();
        tryAutoLoad();

        async function tryAutoLoad() {
            const status = document.getElementById('autoLoadStatus');
            const manual = document.getElementById('manualConnect');

            status.style.display = 'block';
            status.textContent = 'Tentando carregar dados autom√°ticos...';

            try {
                const response = await fetch('n8n_data.json');
                if (!response.ok) throw new Error('Arquivo n8n_data.json n√£o encontrado');

                const data = await response.json();
                console.log('Dados carregados:', Array.isArray(data) ? data.length + ' workflows' : 'Formato inv√°lido');

                if (Array.isArray(data)) {
                    processWorkflows(data);
                    status.textContent = 'Dados carregados automaticamente via GitHub Actions üöÄ';
                    status.style.color = '#3fb950';
                } else {
                    throw new Error('Formato de dados inv√°lido (esperado array)');
                }
            } catch (e) {
                console.error('Falha no auto-load:', e);
                status.style.display = 'none';
                manual.style.display = 'block';
            }
        }

        async function handleFolderSelect(event) {
            const files = Array.from(event.target.files).filter(f => f.name.endsWith('.json'));
            if (files.length === 0) {
                alert('Nenhum arquivo .json encontrado na pasta selecionada.');
                return;
            }

            const status = document.getElementById('autoLoadStatus');
            status.style.display = 'block';
            status.textContent = `Carregando ${files.length} arquivos...`;
            status.style.color = '#58a6ff';

            try {
                const workflowData = [];
                for (const file of files) {
                    const text = await file.text();
                    try {
                        const json = JSON.parse(text);
                        if (Array.isArray(json)) {
                            workflowData.push(...json);
                        } else {
                            workflowData.push(json);
                        }
                    } catch (e) {
                        console.warn(`Erro ao processar ${file.name}:`, e);
                    }
                }

                if (workflowData.length > 0) {
                    processWorkflows(workflowData);
                    status.textContent = `${workflowData.length} fluxos carregados localmente ‚úÖ`;
                    status.style.color = '#3fb950';
                    document.getElementById('manualConnect').style.display = 'none';
                } else {
                    throw new Error('Nenhum dado de workflow v√°lido encontrado.');
                }
            } catch (e) {
                alert('Erro ao processar pasta: ' + e.message);
                status.style.display = 'none';
            }
        }

        async function fetchFromApi() {
            const url = document.getElementById('n8nUrl').value.replace(/\/$/, '');
            const key = document.getElementById('n8nKey').value;
            const btn = document.querySelector('#manualConnect button');

            if (!url || !key) {
                alert('Preencha a URL e a API Key');
                return;
            }

            btn.disabled = true;
            btn.textContent = 'Carregando...';

            try {
                const response = await fetch(`${url}/api/v1/workflows`, {
                    headers: {
                        'X-N8N-API-KEY': key
                    }
                });

                if (!response.ok) throw new Error(`Erro ${response.status}: ${response.statusText}`);

                const data = await response.json();
                const workflows = data.data || data;

                // Need to fetch details for each workflow to get nodes
                const details = await Promise.all(workflows.map(async w => {
                    const r = await fetch(`${url}/api/v1/workflows/${w.id}`, {
                        headers: { 'X-N8N-API-KEY': key }
                    });
                    return r.json();
                }));

                processWorkflows(details);

                // Hide panel after success
                document.getElementById('manualConnect').style.display = 'none';
                const status = document.getElementById('autoLoadStatus');
                status.style.display = 'block';
                status.textContent = 'Conectado diretamente ao n8n ‚úÖ';
                status.style.color = '#3fb950';

            } catch (e) {
                alert('Erro ao conectar: ' + e.message + '\nVerifique se o CORS est√° habilitado no seu n8n.');
            } finally {
                btn.disabled = false;
                btn.textContent = 'Conectar & Carregar';
            }
        }

        // Export to markdown
        function exportMarkdown() {
            let md = '# Documenta√ß√£o de Depend√™ncias n8n\n\n';
            md += `Gerado em: ${new Date().toLocaleString('pt-BR')}\n\n`;

            // Use RAW stats for export
            md += '## Estat√≠sticas\n\n';
            md += `- **Fluxos**: ${rawNodes.filter(n => n.type === 'workflow').length}\n`;
            md += `- **Fontes de Dados**: ${rawNodes.filter(n =>
                n.type.includes('supabase') || n.type.includes('notion') || n.type.includes('bigquery') ||
                n.type.includes('microsoft') || n.type.includes('google') || n.type.includes('openai')
            ).filter(n => !n.type.includes('credential')).length}\n`;
            md += `- **Credenciais**: ${rawNodes.filter(n => n.type.includes('credential')).length}\n\n`;

            md += '## Depend√™ncias por Fonte de Dados\n\n';

            const sources = rawNodes.filter(n =>
                n.type.includes('supabase') || n.type.includes('notion') || n.type.includes('bigquery') ||
                n.type.includes('microsoft') || n.type.includes('google') || n.type.includes('openai')
            ).filter(n => !n.type.includes('credential'));

            // Agrupa por tipo
            const grouped = {};
            sources.forEach(source => {
                let type = getGroup(source);
                if (!grouped[type]) grouped[type] = [];
                grouped[type].push(source);
            });

            Object.keys(grouped).sort().forEach(type => {
                md += `### ${type.charAt(0).toUpperCase() + type.slice(1)}\n\n`;

                grouped[type].forEach(source => {
                    const deps = rawLinks
                        .filter(l => l.target === source.id)
                        .map(l => rawNodes.find(n => n.id === l.source))
                        .filter(n => n && n.type === 'workflow');

                    md += `#### ${source.label}\n`;
                    if (deps.length > 0) {
                        md += `Usado por ${deps.length} fluxo(s):\n`;
                        deps.forEach(wf => md += `- ${wf.label}\n`);
                    } else {
                        md += `Nenhum fluxo utiliza esta fonte.\n`;
                    }
                    md += '\n';
                });
            });

            const blob = new Blob([md], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'n8n-dependencies.md';
            a.click();
        }

        // Initialize
        initGraph();
        function getGroup(node) {
            if (node.type.includes('supabase')) return 'supabase';
            if (node.type.includes('notion')) return 'notion';
            if (node.type.includes('bigquery')) return 'bigquery';
            if (node.type.includes('microsoft')) return 'microsoft';
            if (node.type.includes('google')) return 'google';
            if (node.type.includes('openai')) return 'openai';
            if (node.type.includes('workflow')) return 'workflow';
            // Credential check - now integrated into tools or generic 'other'
            return 'other';
        }
    </script>
</body>

</html>